#include "ScriptHeaderGenerator.h"
#include "../FileWatcher.h"
#include <fstream>
#include <thread>
#include <chrono>
#include "../ConsoleLogger.h"
#include <regex>

namespace ScriptHeaderGenerator
{
	bool IsAutoGenerated(std::filesystem::path path)
	{
		std::ifstream file(path);

		if (file.is_open())
		{
			std::string line;
			std::getline(file, line);

			return line.find("AutoGeneratedHeader") != std::string::npos;
		}

		return false;
	}

	void FileModified(const std::filesystem::path& path)
	{
		if (path.extension() == ".cpp")
		{
			std::filesystem::path headerPath = path;
			headerPath.replace_extension(".h");

			if (!std::filesystem::exists(headerPath) && IsAutoGenerated(headerPath))
				GenerateHeader(path);
		}
		else if (path.extension() == ".h")
		{
			// Todo: Check if the header file is modified by the user, and if the header has the AutoGenerateHeaderd define, then send a warning giving them an option to disable auto generating headers for this script
		}
	}

	void FileMoved(const std::filesystem::path& oldPath, const std::filesystem::path& newPath)
	{
		if (newPath.extension() == ".cpp")
		{
			// Using threads in case the .cpp is moved before the header. Even if a header is already in the new path, its possible the user is trying to overwrite it
			std::thread([oldPath, newPath]() {
				std::this_thread::sleep_for(std::chrono::milliseconds(500));

				std::filesystem::path headerPath = newPath;
				headerPath.replace_extension(".h");

				std::filesystem::path oldHeaderPath = oldPath;
				oldHeaderPath.replace_extension(".h");

				try {
					if (!std::filesystem::exists(headerPath))
					{
						if (std::filesystem::exists(oldHeaderPath))
							std::filesystem::rename(oldHeaderPath, headerPath);
						else
							GenerateHeader(headerPath);
					}
				}
				catch (const std::filesystem::filesystem_error& e) {}
			}).detach();
		}
		else if (newPath.extension() == ".h")
		{
			// Using threads in case the header is moved before the .cpp. Even if a .cpp is already in the new path, its possible the user is trying to overwrite it
			std::thread([oldPath, newPath]() {
				std::this_thread::sleep_for(std::chrono::milliseconds(500));

				std::filesystem::path cppPath = newPath;
				cppPath.replace_extension(".cpp");

				std::filesystem::path oldCppPath = oldPath;
				oldCppPath.replace_extension(".cpp");

				try {
					if (!std::filesystem::exists(cppPath) && std::filesystem::exists(oldCppPath))
						std::filesystem::rename(oldCppPath, cppPath);
				}
				catch (const std::filesystem::filesystem_error& e) {}
			}).detach();
		}
	}

	void FileDeleted(const std::filesystem::path& path)
	{
		if (path.extension() == ".cpp")
		{
			std::filesystem::path headerPath = path;
			headerPath.replace_extension(".h");

			if (std::filesystem::exists(headerPath) && IsAutoGenerated(headerPath)) // Checks if the header still exists and is auto generated
				std::filesystem::remove(headerPath);
		}
		else if (path.extension() == ".h")
		{
			std::filesystem::path cppPath = path;
			cppPath.replace_extension(".cpp");

			if (std::filesystem::exists(cppPath)) // Checks if the cpp still exists
				GenerateHeader(path);
		}
	}

	void Init()
	{
		FileWatcher::AddGlobalModifyCallback("ScriptHeaderGenerator", FileModified);
		FileWatcher::AddGlobalMoveCallback("ScriptHeaderGenerator", FileMoved);
		FileWatcher::AddGlobalDeletedCallback("ScriptHeaderGenerator", FileDeleted);
	}


    void GenerateHeader(std::filesystem::path path)
    {
    //    std::thread([path]() {
    //        try {
    //            // Get the filename without extension to create the header name
    //            std::string filename = path.stem().string();
    //            std::filesystem::path headerPath = path;
    //            headerPath.replace_extension(".h");

    //            // Open the source file
    //            std::ifstream sourceFile(path);
    //            if (!sourceFile.is_open()) {
    //                ConsoleLogger::ErrorLog("Failed to open source file to generate the header. Script: " + path.stem().string(), false);
    //                return;
    //            }

    //            // Read the entire source file
    //            std::string line;
    //            std::vector<std::string> sourceLines;
    //            while (std::getline(sourceFile, line)) {
    //                sourceLines.push_back(line);
    //            }
    //            sourceFile.close();

    //            // Create and open the header file
    //            std::ofstream headerFile(headerPath);
    //            if (!headerFile.is_open()) {
    //                ConsoleLogger::ErrorLog("Failed to create header file to generate the header. Script: " + path.stem().string(), false);
    //                return;
    //            }

    //            // Todo: put tags in relative spots in the header. So if they put it half way through after a PUBLIC function, then put it after that

    //            // Supported tags:
    //            // @INCLUDE ALL

    //            /*
    //            @HEADER_INCLUDES
    //            #include "Player.h"
    //            #include <map>
    //            */

    //            // or maybe just the following and it moves everything within it to the header therefore can be used with like forward declarations, templats, etc.
    //            /*
    //            @HEADER
    //            #include "Player.h"
    //            #include <map>
    //            class ForwardDeclarationExample
    //            */

    //            // #include <example> // @HEADER

    //            // #include <example> // @EXCLUDE -- Can be used if @INCLUDE ALL is used.

    //            // Forward Declaration example:
    //            // class DependentClass // @FORWARD
    //            // Can also do multi-line like includes

    //            // Add header guards
    //            std::string headerGuard = filename;
    //            std::transform(headerGuard.begin(), headerGuard.end(), headerGuard.begin(), ::toupper);
    //            headerGuard += "#pragma once"; // This shouldnt needs its own variable

    //            // Add common includes
    //            headerFile << "#include <vector>" << std::endl;
    //            headerFile << "#include <string>" << std::endl;
    //            headerFile << "#include <memory>" << std::endl << std::endl;

    //            // Extract class name from the source file (assuming class name matches filename)
    //            std::string className = filename;

    //            // Check if there's an explicit class declaration to get the correct class name
    //            for (const auto& line : sourceLines) {
    //                std::regex classRegex(R"(class\s+(\w+))");
    //                std::smatch match;
    //                if (std::regex_search(line, match, classRegex)) {
    //                    className = match[1];
    //                    break;
    //                }
    //            }

    //            // Start class declaration
    //            headerFile << "class " << className << std::endl;
    //            headerFile << "{" << std::endl;

    //            // Define sections
    //            bool inPublicSection = false;
    //            bool inProtectedSection = false;
    //            bool inPrivateSection = false;

    //            // Track what we've already added to the header to avoid duplication
    //            std::unordered_set<std::string> addedDeclarations;

    //            // First pass: collect method declarations by section
    //            std::vector<std::string> publicDeclarations;
    //            std::vector<std::string> protectedDeclarations;
    //            std::vector<std::string> privateDeclarations;

    //            for (const auto& line : sourceLines) {
    //                // Process each line to identify access modifiers and method declarations
    //                if (line.find("PUBLIC") != std::string::npos) {
    //                    std::string declaration = line;

    //                    // Replace PUBLIC with nothing
    //                    declaration = std::regex_replace(declaration, std::regex("PUBLIC\\s+"), "");

    //                    // Handle special case for constructors/destructors with the class name
    //                    if (declaration.find(className + "::") != std::string::npos) {
    //                        declaration = std::regex_replace(declaration, std::regex(className + "::"), "");
    //                    }

    //                    // Extract function signature up to the opening brace or semicolon
    //                    size_t bracePos = declaration.find('{');
    //                    if (bracePos != std::string::npos) {
    //                        declaration = declaration.substr(0, bracePos);
    //                    }

    //                    // Handle default parameter values
    //                    declaration = std::regex_replace(declaration, std::regex("/\\*\\s*=\\s*([^*]*)\\*/"), " = $1");

    //                    // Add semicolon if missing
    //                    if (declaration.find(';') == std::string::npos) {
    //                        declaration = declaration + ";";
    //                    }

    //                    // Trim whitespace
    //                    declaration = std::regex_replace(declaration, std::regex("^\\s+|\\s+$"), "");

    //                    if (!declaration.empty() && addedDeclarations.find(declaration) == addedDeclarations.end()) {
    //                        publicDeclarations.push_back(declaration);
    //                        addedDeclarations.insert(declaration);
    //                    }
    //                }
    //                else if (line.find("PROTECTED") != std::string::npos) {
    //                    std::string declaration = line;
    //                    declaration = std::regex_replace(declaration, std::regex("PROTECTED\\s+"), "");

    //                    if (declaration.find(className + "::") != std::string::npos) {
    //                        declaration = std::regex_replace(declaration, std::regex(className + "::"), "");
    //                    }

    //                    size_t bracePos = declaration.find('{');
    //                    if (bracePos != std::string::npos) {
    //                        declaration = declaration.substr(0, bracePos);
    //                    }

    //                    declaration = std::regex_replace(declaration, std::regex("/\\*\\s*=\\s*([^*]*)\\*/"), " = $1");

    //                    if (declaration.find(';') == std::string::npos) {
    //                        declaration = declaration + ";";
    //                    }

    //                    declaration = std::regex_replace(declaration, std::regex("^\\s+|\\s+$"), "");

    //                    if (!declaration.empty() && addedDeclarations.find(declaration) == addedDeclarations.end()) {
    //                        protectedDeclarations.push_back(declaration);
    //                        addedDeclarations.insert(declaration);
    //                    }
    //                }
    //                else if (line.find("PRIVATE") != std::string::npos) {
    //                    std::string declaration = line;
    //                    declaration = std::regex_replace(declaration, std::regex("PRIVATE\\s+"), "");

    //                    if (declaration.find(className + "::") != std::string::npos) {
    //                        declaration = std::regex_replace(declaration, std::regex(className + "::"), "");
    //                    }

    //                    size_t bracePos = declaration.find('{');
    //                    if (bracePos != std::string::npos) {
    //                        declaration = declaration.substr(0, bracePos);
    //                    }

    //                    declaration = std::regex_replace(declaration, std::regex("/\\*\\s*=\\s*([^*]*)\\*/"), " = $1");

    //                    if (declaration.find(';') == std::string::npos) {
    //                        declaration = declaration + ";";
    //                    }

    //                    declaration = std::regex_replace(declaration, std::regex("^\\s+|\\s+$"), "");

    //                    if (!declaration.empty() && addedDeclarations.find(declaration) == addedDeclarations.end()) {
    //                        privateDeclarations.push_back(declaration);
    //                        addedDeclarations.insert(declaration);
    //                    }
    //                }
    //                else if (line.find("STATIC") != std::string::npos) {
    //                    // Handle static members, assume public by default unless specified
    //                    std::string declaration = line;
    //                    declaration = std::regex_replace(declaration, std::regex("STATIC\\s+"), "static ");

    //                    if (declaration.find(className + "::") != std::string::npos) {
    //                        declaration = std::regex_replace(declaration, std::regex(className + "::"), "");
    //                    }

    //                    size_t bracePos = declaration.find('{');
    //                    if (bracePos != std::string::npos) {
    //                        declaration = declaration.substr(0, bracePos);
    //                    }

    //                    declaration = std::regex_replace(declaration, std::regex("/\\*\\s*=\\s*([^*]*)\\*/"), " = $1");

    //                    if (declaration.find(';') == std::string::npos) {
    //                        declaration = declaration + ";";
    //                    }

    //                    declaration = std::regex_replace(declaration, std::regex("^\\s+|\\s+$"), "");

    //                    // If it has PUBLIC, PROTECTED, or PRIVATE, remove those indicators
    //                    if (declaration.find("PUBLIC") != std::string::npos) {
    //                        declaration = std::regex_replace(declaration, std::regex("PUBLIC\\s+"), "");
    //                        if (!declaration.empty() && addedDeclarations.find(declaration) == addedDeclarations.end()) {
    //                            publicDeclarations.push_back(declaration);
    //                            addedDeclarations.insert(declaration);
    //                        }
    //                    }
    //                    else if (declaration.find("PROTECTED") != std::string::npos) {
    //                        declaration = std::regex_replace(declaration, std::regex("PROTECTED\\s+"), "");
    //                        if (!declaration.empty() && addedDeclarations.find(declaration) == addedDeclarations.end()) {
    //                            protectedDeclarations.push_back(declaration);
    //                            addedDeclarations.insert(declaration);
    //                        }
    //                    }
    //                    else if (declaration.find("PRIVATE") != std::string::npos) {
    //                        declaration = std::regex_replace(declaration, std::regex("PRIVATE\\s+"), "");
    //                        if (!declaration.empty() && addedDeclarations.find(declaration) == addedDeclarations.end()) {
    //                            privateDeclarations.push_back(declaration);
    //                            addedDeclarations.insert(declaration);
    //                        }
    //                    }
    //                    else {
    //                        // Default to public for static members if no access specifier
    //                        if (!declaration.empty() && addedDeclarations.find(declaration) == addedDeclarations.end()) {
    //                            publicDeclarations.push_back(declaration);
    //                            addedDeclarations.insert(declaration);
    //                        }
    //                    }
    //                }
    //            }

    //            // Write public declarations first
    //            if (!publicDeclarations.empty()) {
    //                headerFile << "public:" << std::endl;
    //                for (const auto& decl : publicDeclarations) {
    //                    headerFile << "    " << decl << std::endl;
    //                }
    //                headerFile << std::endl;
    //            }

    //            // Write protected declarations
    //            if (!protectedDeclarations.empty()) {
    //                headerFile << "protected:" << std::endl;
    //                for (const auto& decl : protectedDeclarations) {
    //                    headerFile << "    " << decl << std::endl;
    //                }
    //                headerFile << std::endl;
    //            }

    //            // Write private declarations
    //            if (!privateDeclarations.empty()) {
    //                headerFile << "private:" << std::endl;
    //                for (const auto& decl : privateDeclarations) {
    //                    headerFile << "    " << decl << std::endl;
    //                }
    //                headerFile << std::endl;
    //            }

    //            // Close class declaration
    //            headerFile << "};" << std::endl << std::endl;

    //            // Close header guard
    //            headerFile << "#endif // " << headerGuard << std::endl;

    //            headerFile.close();

    //            ConsoleLogger::InfoLog("Successfully generated header file: " + headerPath.string(), true);
    //        }
    //        catch (const std::exception& e) {
    //            ConsoleLogger::ErrorLog("Error generating the header file \"" + path.stem().string() + "\". Error: " + e.what());
    //        }
    //    }).detach();
    }
}